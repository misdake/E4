AssetPool

//    E4::AssetPool<int> assetPool;
//    E4::Asset<int> p1 = assetPool.alloc();
//    p1.get() = 1;
//    E4::Asset<int> p2 = assetPool.alloc();
//    p2.get() = 2;
//    E4::Asset<int> p3 = assetPool.alloc();
//    p3.get() = 3;
//    std::cout << p1.get() << p2.get() << p3.get() << " addr:" << &p2.get() << std::endl;
//    assetPool.shrintToFit();
//    std::cout << p1.get() << p2.get() << p3.get() << " addr:" << &p2.get() << std::endl;
//
//    p2.free();
//    p2.get(); //invalid
//    assetPool.printEmpty();

//    E4::Asset<int> p4 = assetPool.alloc();
//    p4.get() = 4;
//    E4::Asset<int> p5 = assetPool.alloc();
//    p5.get() = 5;
//    std::cout << p1.get() << p4.get() << p5.get() << " addr:" << &p4.get() << std::endl; //145, addr(p4) should be equal to addr(p2)




Matrix

//void gldPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) {
//    // This code is based off the MESA source for gluPerspective
//    // *NOTE* This assumes GL_PROJECTION is the current matrix
//
//
//    GLdouble xmin, xmax, ymin, ymax;
//    GLdouble m[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
//
//    ymax = zNear * tan(fovy * M_PI / 360.0);
//    ymin = -ymax;
//
//    xmin = ymin * aspect;
//    xmax = ymax * aspect;
//
//    // Set up the projection matrix
//    m[0 + 0 * 4] = (2.0 * zNear) / (xmax - xmin);
//    m[1 + 1 * 4] = (2.0 * zNear) / (ymax - ymin);
//    m[2 + 2 * 4] = -(zFar + zNear) / (zFar - zNear);
//
//    m[0 + 2 * 4] = (xmax + xmin) / (xmax - xmin);
//    m[1 + 2 * 4] = (ymax + ymin) / (ymax - ymin);
//    m[3 + 2 * 4] = -1.0;
//
//    m[2 + 3 * 4] = -(2.0 * zFar * zNear) / (zFar - zNear);
//
//    // Add to current matrix
//    glMultMatrixd(m);
//}




Lua

//    sol::state lua;
//    int x = 0;
//    lua.set_function("beep", [&x] { ++x; });
//    lua.script("beep()");
//    std::cout << x << std::endl;




CNtity
//    struct Position {
//        float x;
//        float y;
//    };
//    struct Velocity {
//        float x;
//        float y;
//    };
//    struct Health {
//        int max;
//        int current;
//    };
//
//
//
//
//    CNtity::CNtity<Position, Velocity, Health, std::string> cntity;
//
//    //Creating entities
//    auto chat = cntity.create<std::string>({"chat"});
//    cntity.create<std::string>({"chien"});
//    cntity.create<std::string, Position>({"velociraptor"}, {25, 70});
//
//    //Adding component, changing values
//    auto position = cntity.add<Position>(chat, {50, 50});
//    position->x += 50;
//
//    //System 1
//    cntity.for_each<std::string, Position>([&cntity](auto entity, auto identity) {
//        if (*identity == "chat") {
//            auto position = cntity.get<Position>(entity);
//            position->x = 200;
//            position->y = 70;
//
//            return;
//        }
//    });
//
//    //System 2
//    for (const auto& it: cntity.acquire<std::string, Position>()) {
//        if (*cntity.get<std::string>(it) == "chat") {
//            auto position = cntity.get<Position>(it);
//            std::cout << "position: (" << position->x << ", " << position->y << ")" << std::endl;
//        }
//    }
//
//    //Removing a component, erasing an entity
//    cntity.remove<Position>(chat);
//    cntity.erase(chat);