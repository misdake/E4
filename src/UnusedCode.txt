AssetPool

//    E4::AssetPool<int> assetPool;
//    E4::Asset<int> p1 = assetPool.alloc();
//    p1.get() = 1;
//    E4::Asset<int> p2 = assetPool.alloc();
//    p2.get() = 2;
//    E4::Asset<int> p3 = assetPool.alloc();
//    p3.get() = 3;
//    std::cout << p1.get() << p2.get() << p3.get() << " addr:" << &p2.get() << std::endl;
//    assetPool.shrintToFit();
//    std::cout << p1.get() << p2.get() << p3.get() << " addr:" << &p2.get() << std::endl;
//
//    p2.free();
//    p2.get(); //invalid
//    assetPool.printEmpty();

//    E4::Asset<int> p4 = assetPool.alloc();
//    p4.get() = 4;
//    E4::Asset<int> p5 = assetPool.alloc();
//    p5.get() = 5;
//    std::cout << p1.get() << p4.get() << p5.get() << " addr:" << &p4.get() << std::endl; //145, addr(p4) should be equal to addr(p2)




Matrix

//void gldPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) {
//    // This code is based off the MESA source for gluPerspective
//    // *NOTE* This assumes GL_PROJECTION is the current matrix
//
//
//    GLdouble xmin, xmax, ymin, ymax;
//    GLdouble m[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
//
//    ymax = zNear * tan(fovy * M_PI / 360.0);
//    ymin = -ymax;
//
//    xmin = ymin * aspect;
//    xmax = ymax * aspect;
//
//    // Set up the projection matrix
//    m[0 + 0 * 4] = (2.0 * zNear) / (xmax - xmin);
//    m[1 + 1 * 4] = (2.0 * zNear) / (ymax - ymin);
//    m[2 + 2 * 4] = -(zFar + zNear) / (zFar - zNear);
//
//    m[0 + 2 * 4] = (xmax + xmin) / (xmax - xmin);
//    m[1 + 2 * 4] = (ymax + ymin) / (ymax - ymin);
//    m[3 + 2 * 4] = -1.0;
//
//    m[2 + 3 * 4] = -(2.0 * zFar * zNear) / (zFar - zNear);
//
//    // Add to current matrix
//    glMultMatrixd(m);
//}




Lua

//    sol::state lua;
//    int x = 0;
//    lua.set_function("beep", [&x] { ++x; });
//    lua.script("beep()");
//    std::cout << x << std::endl;